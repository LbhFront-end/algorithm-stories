## 算法枕边书

### 第一章

#### 用谜语解开算法世界

从前，有个小岛只住着和尚。有些和尚的眼睛是红色的，而另一些是褐色的。红色眼睛的和尚受到诅咒，如果得知自己的眼睛是红色的，那么当晚12点必须自行了断。

和尚们之间有一条不成文的规定，彼此不能提及对方眼睛的颜色。小岛上也没有镜子，也没有可以反射自己容貌的物体。因此，任何人都无从得知自己的眼睛的颜色。出于这些原因，每个和尚都过着幸福的日子，也没有一个和尚自我了断。

有一天，岛上来了一个旅客，她对这个诅咒毫不知情，因而，这位游客对和尚们说：

“你们当中至少有一个位的眼睛是红色的”。

无心游客离去，和尚们却惴惴不安，那么会出现什么最坏的情况？

答案：若小岛上共有 n 个红眼游客，那么第 n 个晚上将有 n 个 和尚同时自我了断。



#### 设计精妙算法

有一个能够保存99个数值的数组 item[0], item[1], item[2],..., item[98]。从拥有1~100 元素的集合 {1,2,3,4,5,...,100}中，随机抽取99个元素保存到数组中，集合共有100个元素，而数组只能保存99个元素，所以集合一定会留下一个元素，问集合中剩下的一个元素是什么。

```javascript
const total = 5050;
for(var i = 0; i< 100; i++){
    total = total - item[i];
}
console.log(` 剩下的数值是 ${total}`);
```



### 回文世界

无论正着读还是倒着读全都相同的单词或短语称为“回文”（palindrome ）。编写函数，判断输入的字符串是否为回文，是为true，否则为false

```javascript
function isPalindrome(palindrome){
    if (!palindrome) return false; // null或undefined
    palindrome += "";
    for(var i = 0;  i < palindrome.length/2; i++){
        if(palindrome[i] !== palindrome[palindrome.length-i-1] ){

            return false;
        }				
        return true;
    }
}
```

上面这种方式是传统的采取比较字符串的第一位与最后一位并前后逐个比较的方法，当字符串比较短的时候，可以采用这种方法。可以明显注意到，每次执行循环的时候，都会执行一次 `palinedrome.length-i-1`。如果可以把它放在 for 循环的外面执行，就可以提高效率。

下面这种方法是利用 javaScript 自带的一些方法实现的。

```javascript
function isPalindrome(palindrome){
    if (!palindrome) return false; // null或undefined
    palindrome += "";
    return palindrome === palindrome.split('').reverse().join('');
}
```

这种方法很方便，但效率不高，字符串分割，倒转，聚合都需要很多额外的操作。 

另外有 一则数学观察报道与回文相关，非常有趣。1984年，计算机科学家在一篇杂志上，发表了一篇文章。提出了一个有趣的算法。

1. 选择任意数值；
2. 翻转此数值（例如，13 -> 31）,并将原数值和翻转的数字相加（13 + 31）
3. 相加的结果若不是回文数，则返回2反复执行，若是回文则终止算法。

大部分数值会有回文数，但也不能证明所有数值会有对应的回文数。有些数值妨碍了算法的通用性，其中最小的数就是 196 。

这个数值被称为 “196数值” 或 “196问题”。

